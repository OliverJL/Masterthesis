\chapter{The Next Chapter}
\label{cha:2}

\section{Operating System Virtualization with the Xen-Hypervisor}

Virtualization of operating systems has increased continuously over the recent years and layed the foundations for new resource management concepts and business models like f.e. cloud hosting. Regarding server virtualization, many organizations exceed rates of 75\% \cite{gartnervmmarket}. By executing an operating system as a virtual machine (VM), improvements in several areas can be achieved. As instances of even different operating systems can be run parallel on the same host machine, system capacity in terms of processing power, volatile and persistent memory can be utilized more efficient. A VM can even be assigned resources dynamically at runtime, without the need of a restart. Further, backup \& recovery strategies can be simplified, as a VM's physical presentation at any certain state can be preserved in files. This even enables to move a running VM from one to another server in the same resource pool with virtually no service interruption \cite{migratevms}. Also the process of providing a new VM instance can be slimmed down drastically. Instead of being required to execute an operating system setup for a particular hardware composition, a once created VM master image can be cloned and configured. Depending on the applied technology, VMs can be setup up on basis of operating system setup images which are targeted for installation directly on hardware, without any further modification required. In other words, the virtual machine monitor or hypervisor enables the execution of regular proprietary or open source operating systems in a virtual environment. \\
According to a study of Gartner from 2016, the market for x86 server virtualization infrastructure software is partitioned among few competitors, led by VMWare, Microsoft, Oracle and Red Hat. While VMWare and Microsoft offer proprietary solutions, Oracle and Red Hat adopted the open-source Xen-hypervisor technology. For cloud infrastructures, the Xen-Hypervisor remains the most widely used architecture for public infrastructure as a service (IaaS) cloud provider. This fact is predominantly attributable to Amazon's utilization of the Xen-Hypervisor for its cloud solutions "Amazon Web Services" \cite{bittman2016magic}.
\\~\\
Hier muss noch ein Uebergang hin
\\


- Open Source
- Amazon
- Verbreitung 
- HVM / PVM
- Architektur

------------------------------------
\cite{everspaugh2014not}
Second,aVM  can be repeatedly executed froma ?xed image which is the default for amazon
Dort auch: infos zu regualr boot/snapshot/masterimage
------------------------------------



However, while there are many reasons to utilize virtual machines, most of the standard security practices of operating systems are based on assumptions that hold true for physical machines, but don't translate immediately into the domain of virtualized machines \cite{kerrigan2012study}. A virtual hosted Linux server f.e. will never receive a user triggered event during the boot process, which is a critical period within the initialization of the internal Linux PRNG. Further, new virtual machine instances are usually provided by cloning a master image, instead of running an installation setup, leading to a higher degree of homogeneity among virtual machine instances. While provisioning time and maintenance benefit from this practice, it may be regarded critical. If this approach f.e. is applied as the standard process of a cloud hosting provider, it`s customers may be delivered a vulnerable system from the outset, since one customer might gain insights regarding another customers system, just by analyzing his own. These insights can be used to exploit VM reset vulnerabilities which take advantage of the reuse of  operating system snapshots, so called snapshot replay. Thomas Ristenpart et. al. describe this type of attack and apply it on TSL implementations with disastrous results. Relevant reasons they identified are the exposure of randomness, as well as the inability to find sufficient entropy in virtual systems environments \cite{ristenpart2010good, ristenpart2009hey}. \\~\\
According to a study of Gartner from 2016, the market for x86 server virtualization infrastructure software is partitioned among few competitors, led by VMWare, Microsoft, Oracle and Red Hat. While VMWare and Microsoft offer proprietary solutions, Oracle and Red Hat adopted the open-source Xen-hypervisor technology. For cloud infrastructures, the Xen-hypervisor remains the most widely used architecture for public infrastructure as a service (IaaS) cloud provider. This fact is predominantly attributable to Amazon's utilization of the Xen-hypervisor for its cloud solutions "Amazon Web Services" \cite{bittman2016magic}. 

Similarly, the market of common server operating systems can be divided into proprietary and open-source solutions. While Microsoft dominates the fraction of proprietary systems with its Windows Server series, Linux based systems have a total share of \~37\%. Within this share, \~39\% of servers dedicated to host websites etc. are running an Ubuntu Distribution \cite{statsharelinux} . \\~\\


\section{Random Number Generation in Linux x64 Kernel 4.4}

\subsection{General}

Random numbers are required by a variety of security related applications. An obvious purpose is encryption or signing of data, like f.e. disk encryption, Transport Socket Layer (TLS) or digital signatures of emails. In this case random numbers are used to generate cryptographically secure keys. Concepts like Stack Canaries (aka. Stack Guards) or Address Space Layout Randomization (ASLR) rely purely on the nondeterministic character of random numbers, applying them to make certain types of attacks on vulnerable applications much more difficult. Overall, the effectiveness of such applications depends significantly on the quality i.e. unpredictably of random numbers, provided by an operating system. \\
In the following a comprehensive introduction to the Linux Random Number Generator (LRNG) with focus on analyzed concepts and components of this thesis will be given. It refers to Linux kernel v.4.4, which is currently used in several major Long Term Support distributions like Ubuntu Server 16.04 LTS. If facts are valid for Intel x86/x64 platforms only, those will be noted as such.\\
In general, many modern CPU-architectures implement an on-chip True Random Number Generator \cite{guide2017intel}. Starting with 'IvyBridge' architecture, Intel provides two instructions accessing directly those entropy sources. The \textsf{RDRAND} instruction returns random numbers that are supplied by a cryptographically secure, deterministic random bit generator (DRBG). The DRBG is designed to meet the NIST SP 800-90A standard. If an application or operating system design insists on applying in it's own Pseudo Random Number Generator (PRNG) it may apply the \textsf{RDSEED} instruction which is compliant to NIST SP 800-90B \& C standard \cite{guide2017intel}.
Availability of these TRNGs does not automatically imply their application. If a kernel is started 
with paramter \textsf{nordrand} (on x86/x64 architectures), the \textsf{RDRAND} instruction will have no effect. Further, if an operating system is run as a virtual machine, those instructions can by trapped by the hypervisor instead of being passed to the CPU \cite{mueller@bsi2}. Thus the analysis in this thesis does not take on-chip entropy pools into account, but refers to the pure Linux Pseudo Random Number Generator).

\subsection{Linux Pseudo Random Number Generator Architecture}
The Linux Pseudo Random Number Generator's (PRNG) responsibility is to provide random numbers to requesting consumers. To ensure a certain quality of randomness the implementations activity may be divided into four major tasks:   

\centering
\begin{itemize}
	\item Capturing and processing input data which is finally stored in entropy pools
	\item Assessing the level of entropy in each pool
	\item Diverting incoming entropy 
\end{itemize}


generates random numbers based on occurring hardware events. Those events 


\begin{comment}
Jegliche Nutzung der RDRAND-Instruktion kann verhindert werden, wenn der Kern mit der
Kommandozeilenoption ?nordrand? gestartet wird.
Es ist zu beachten, dass RDRAND von einem Hypervisor im Sinne eines VM-Exits abgefangen
und verändert beziehungsweise nicht an die CPU weitergegeben werden kann.

\end{comment}


implementation

Intel IvyBridge x86 



Intro:
valid kernel for x64  4.4. (16.04 LTS)
MISP 

 

arch:
Intel IvyBridge x86-Prozessorgeneration
TRNG
 \cite guide2017intel
RDRAND returns random numbers that are supplied by a cryptographically secure, deterministic random bit generator DRBG. The DRBG is designed to meet the NIST SP 800-90A standard.
RDSEED
Non-deterministic random bit generator
NIST SP 800-90B \& C
\cite{guide2017intel}


Diff: kernel/Userspace request

\begin{comment}
Aktuelle Arbeiten zeigen, dass gerade im Bereich von Headless-Systemen, die beim
ersten Systemstart Zufallszahlen für die Erzeugung von Schlüsseln benötigen, zu
wenig Entropie vorhanden ist. Auch wenn von den Interrupts nicht viel Entropie zu
erwarten ist, sollte die Verwendung der Interrupt-Ereignisse dieses Problem etwas
abmildern.
\cite{mueller@bsi2}
\end{comment}


\begin{figure}[H]
%\centering
\input{add-interrupt-rnd.tex}
\caption{Processing of input parameters by func. 'add\_interrupt\_randomness' before applying fast\_mix / mix\_pool\_bytes operations (valid for 64-bit Kernel only)} \label{fig:add-int-rnd-chart}
\end{figure}


%\begin{mdframed}
%\begin{tabularx}{\columnwidth}{XXl}
%\begin{tabularx}{\textwidth}{ll}
%%	\caption{Description of input parameters proccessed by func. 'add\_interrupt\_randomness'}
%%	\label{tab:add-int-rnd-desc}\\
%	\textbf{jiffies}&Igel\\
%	\textbf{cycles counter}&Dienstag\\
%	\textbf{irq}&\\
%	\textbf{ip}&\textit{Instruction Pointer}
%	\caption{Description of input parameters proccessed by func. 'add\_interrupt\_randomness'}
%\end{tabularx}
%\centering
%\begin{table}[H]
%	\begin{tabular}{ll}
%	\textbf{Jiffies}&Nr. of ticks occured since system startup.\\
%	\textbf{Cycles Counter}&Nr. of CPU-cycles since system startup.\\
%	\textbf{irq}&Interrupt Request \\
%	\textbf{ip}&\textit{Instruction Pointer}
%	\end{tabular}
%	\caption{Description of input parameters proccessed by func. 'add\_interrupt\_randomness'}	
%\end{table}

% jiffies . Incremented for each timer interrupt.
% . also known as \textit{Time Stamp Counter}.

%	\cite{kernlrandmc}
		
%\end{mdframed}


%\begin{tabularx}{\columnwidth}{XXl}
%	jiffies&Schnecke&Igel\\
%	cycles counter&Hier ist ein langes Wort Hier ist ein langes Wort Hier ist ein langes Wort Hier ist ein langes Wort &Dienstag\\
%	irq&&\\
%	ip&&
%\end{tabularx}
%
%
%
%\begin{mdframed}
%\begin{description}
%	\item [jiffies] sadfasdfsadf
%	\item [cycles counter] asdfasdfasdf
%	\item [irq] asdfasdfasdf	
%	\item [ip] 
%\end{description}
%\cite{kernlrandmc}	
%\end{mdframed}




\section{Conclusion}
The final section of the chapter gives an overview of the important results
of this chapter. This implies that the introductory chapter and the
concluding chapter don't need a conclusion.

\lipsum[66]

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 
