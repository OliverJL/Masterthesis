\chapter{The Next Chapter}
\label{cha:2}

\section{Operating System Virtualization with the Xen-Hypervisor}

Virtualization of operating systems has increased continuously over the recent years and layed the foundations for new resource management concepts and business models like f.e. cloud hosting. Regarding server virtualization, many organizations exceed rates of 75\% \cite{gartnervmmarket}. By executing an operating system as a virtual machine (VM), improvements in several areas can be achieved. As instances of even different operating systems can be run parallel on the same host machine, system capacity in terms of processing power, volatile and persistent memory can be utilized more efficient. A VM can even be assigned resources dynamically at runtime, without the need of a restart. Further, backup \& recovery strategies can be simplified, as a VM's physical presentation at any certain state can be preserved in files. This even enables to move a running VM from one to another server in the same resource pool with virtually no service interruption \cite{migratevms}. Also the process of providing a new VM instance can be slimmed down drastically. Instead of being required to execute an operating system setup for a particular hardware composition, a once created VM master image can be cloned and configured. Depending on the applied technology, VMs can be setup up on basis of operating system setup images which are targeted for installation directly on hardware, without any further modification required. In other words, the virtual machine monitor or hypervisor enables the execution of regular proprietary or open source operating systems in a virtual environment. \\
According to a study of Gartner from 2016, the market for x86 server virtualization infrastructure software is partitioned among few competitors, led by VMWare, Microsoft, Oracle and Red Hat. While VMWare and Microsoft offer proprietary solutions, Oracle and Red Hat adopted the open-source Xen-hypervisor technology. For cloud infrastructures, the Xen-Hypervisor remains the most widely used architecture for public infrastructure as a service (IaaS) cloud provider. This fact is predominantly attributable to Amazon's utilization of the Xen-Hypervisor for its cloud solutions "Amazon Web Services" \cite{bittman2016magic}.
\\~\\
Hier muss noch ein Uebergang hin
\\


- Open Source
- Amazon
- Verbreitung 
- HVM / PVM
- Architektur

------------------------------------
\cite{everspaugh2014not}
Second,aVM  can be repeatedly executed froma ?xed image which is the default for amazon
Dort auch: infos zu regualr boot/snapshot/masterimage
------------------------------------



However, while there are many reasons to utilize virtual machines, most of the standard security practices of operating systems are based on assumptions that hold true for physical machines, but don't translate immediately into the domain of virtualized machines \cite{kerrigan2012study}. A virtual hosted Linux server f.e. will never receive a user triggered event during the boot process, which is a critical period within the initialization of the internal Linux PRNG. Further, new virtual machine instances are usually provided by cloning a master image, instead of running an installation setup, leading to a higher degree of homogeneity among virtual machine instances. While provisioning time and maintenance benefit from this practice, it may be regarded critical. If this approach f.e. is applied as the standard process of a cloud hosting provider, it`s customers may be delivered a vulnerable system from the outset, since one customer might gain insights regarding another customers system, just by analyzing his own. These insights can be used to exploit VM reset vulnerabilities which take advantage of the reuse of  operating system snapshots, so called snapshot replay. Thomas Ristenpart et. al. describe this type of attack and apply it on TSL implementations with disastrous results. Relevant reasons they identified are the exposure of randomness, as well as the inability to find sufficient entropy in virtual systems environments \cite{ristenpart2010good, ristenpart2009hey}. \\~\\
According to a study of Gartner from 2016, the market for x86 server virtualization infrastructure software is partitioned among few competitors, led by VMWare, Microsoft, Oracle and Red Hat. While VMWare and Microsoft offer proprietary solutions, Oracle and Red Hat adopted the open-source Xen-hypervisor technology. For cloud infrastructures, the Xen-hypervisor remains the most widely used architecture for public infrastructure as a service (IaaS) cloud provider. This fact is predominantly attributable to Amazon's utilization of the Xen-hypervisor for its cloud solutions "Amazon Web Services" \cite{bittman2016magic}. 

Similarly, the market of common server operating systems can be divided into proprietary and open-source solutions. While Microsoft dominates the fraction of proprietary systems with its Windows Server series, Linux based systems have a total share of \~37\%. Within this share, \~39\% of servers dedicated to host websites etc. are running an Ubuntu Distribution \cite{statsharelinux} . \\~\\


\section{Random Number Generation in Linux x64 Kernel 4.4}

\subsection{General}\label{sec:lrng-general}

Random numbers are required by a variety of security related applications. An obvious purpose is encryption or signing of data, like f.e. disk encryption, Transport Socket Layer (TLS) or digital signatures of emails. In this case random numbers are used to generate cryptographically secure keys. Concepts like Stack Canaries (aka. Stack Guards) or Address Space Layout Randomization (ASLR) rely purely on the nondeterministic character of random numbers, applying them to make certain types of attacks on vulnerable applications much more difficult. Overall, the effectiveness of such applications depends significantly on the quality i.e. unpredictably of random numbers, provided by an operating system. \\
In the following, a comprehensive introduction to the Linux Random Number Generator (LRNG) with focus on analyzed concepts and components of this thesis will be given. It refers to Linux kernel v.4.4, which is currently used in several major Long Term Support distributions like Ubuntu Server 16.04 LTS. If facts are valid for Intel x86/x64 platforms only, those will be noted as such.\\
In general, many modern CPU-architectures implement an on-chip True Random Number Generator \cite{guide2017intel}. Starting with 'IvyBridge' architecture, Intel provides two instructions accessing directly those entropy sources. The \textsf{RDRAND} instruction returns random numbers that are supplied by a cryptographically secure, deterministic random bit generator which is designed to meet the NIST SP 800-90A standard. If an application or operating system design insists on applying in it's own Pseudo Random Number Generator (PRNG) it may apply the \textsf{RDSEED} instruction which is compliant to NIST SP 800-90B \& C standard \cite{guide2017intel} for initializing i.e. seeding its state.
Availability of these TRNGs does not automatically imply their application. If a kernel is started 
with paramter \textsf{nordrand} (on x86/x64 architectures), the \textsf{RDRAND} instruction will have no effect. Further, if an operating system is run as a virtual machine, those instructions can by trapped by the hypervisor instead of being passed to the CPU \cite{mueller@bsi2}. Thus the analysis in this thesis does not take on-chip entropy pools into account, but refers to the pure Linux Pseudo Random Number Generator.

\subsection{Linux Pseudo Random Number Generator Architecture Overview}\label{sec:lrng-arch}
The Linux Pseudo Random Number Generator's (PRNG) responsibility is to provide random numbers to requesting consumers. To ensure a certain quality of randomness the implementation's activity may be divided into four major tasks:   

%\begin{figure}
\begin{itemize}
	\item Capturing and processing of input data which is finally stored in entropy pools or buffers
	\item Assessing the level of entropy in each pool in unit 'bits of entropy'
	\item Diverting incoming entropy to a specific pool, depending on a pools state
	\item Releasing random numbers to a consumer 
\end{itemize}
%	\caption{Major tasks of the Linux PRNG}
%\end{figure}
Depending on the type of consumer, there is a fundamental difference in the way random numbers can be requested. Applications or services running in user mode access those via different interfaces than logic running with kernel privileges does. Also, the source of entropy varies vastly, depending on the consumer type. The security components analyzed in this thesis are involved in the generation of new processes. This task is accomplished by code running on kernel level, hence the initialization and management of entropy sources for this consumer type are in focus of this introduction, but partly overlap with those dedicated to user mode consumers.
\\~\\
To generate random numbers, the Linux PRNG needs to fall back on events delivered by hardware. 
Capturing and processing of several types of hardware events starts immediately after the kernel has been loaded into memory and is given execution by the boot loader. With the occurrence of each type of hardware event, more or less sophisticated transformations are applied on the delivered input parameters. Those may be as simple as a single XOR- or ADD-operation to more complex but lean transformations involving previously calculated results. The outcome of these operations is assigned to \textit{entropy pools}. An entropy pool is a data structure located in kernel memory. Beside storing the generated random numbers, it is also aware of its entropy state. In total, there exist three full-featured entropy pools which will be explained in the following TODO Ref??. Some hardware events are processed by a so called \textit{fast\_pool} which must be seen as some kind of transformation stage instead of an entropy pool \cite{mueller@bsi2}. Additionally, part of the the initialization process is the set up of a 16 byte \textit{random int secret buffer}, which is assigned once during system startup. This buffer is also involved in the later delivery of random numbers requested by kernel consumers. Hence it's development is of particular interest for this thesis. Figure \ref{fig:linux-prng-arch} illustrates all major components involved in the generation and management of random numbers via the Linux PRNG. The following sections will explain there dedication and interaction more briefly.

\begin{figure}[H]
	\centering
	\input{linux-prng-arch.tex}
	\caption{Input sources and entropy pools / buffers of the Linux PRNG} 
	\label{fig:linux-prng-arch}
\end{figure}

\subsection{Input sources of the Linux PRNG}
In best case the generation of random numbers is conducted by dedicated devices in terms of True Random Number Generators. The Linux RNG implementation allows to involve TRNGs in two ways: 
\begin{itemize}
	\item \textit{Instruction Delegation} Requests from consumers are directly translated into instructions using architecture dependent on-chip features as described in \ref{sec:lrng-general}.
	This approach bypasses the entire logic of the Linux PRNG and relies completely on the TRNG.
	\item \textit{TRNG/PRNG Hybrid Mode} Random numbers are managed via the regular PRNG logic. Instead of transformed hardware events, the entropy pools are filled with data provided by a TRNG device via a special driver interface.
\end{itemize}
For this thesis, both of those options is out of scope. Instead, the process of generating random numbers based on common hardware events is analyzed. As an outcome, it turned out that just two types of hardware events were able to provide input data, while the reaming did not contribute anything at all, since the operating system was run as a virtual machine. Despite this, those should be mentioned for the sake of completeness.

% In total there are X types 

% Those will be explained in XXX and YYY.  



%generates random numbers based on occurring hardware events. Those events 


\begin{comment}
Jegliche Nutzung der RDRAND-Instruktion kann verhindert werden, wenn der Kern mit der
Kommandozeilenoption ?nordrand? gestartet wird.
Es ist zu beachten, dass RDRAND von einem Hypervisor im Sinne eines VM-Exits abgefangen
und verändert beziehungsweise nicht an die CPU weitergegeben werden kann.

\end{comment}


%implementation
%
%Intel IvyBridge x86 
%
%
%
%Intro:
%valid kernel for x64  4.4. (16.04 LTS)
%MISP 
%
% 
%
%arch:
%Intel IvyBridge x86-Prozessorgeneration
%TRNG
% \cite guide2017intel
%RDRAND returns random numbers that are supplied by a cryptographically secure, deterministic random bit generator DRBG. The DRBG is designed to meet the NIST SP 800-90A standard.
%RDSEED
%Non-deterministic random bit generator
%NIST SP 800-90B \& C
%\cite{guide2017intel}
%
%
%Diff: kernel/Userspace request

\begin{comment}
Aktuelle Arbeiten zeigen, dass gerade im Bereich von Headless-Systemen, die beim
ersten Systemstart Zufallszahlen für die Erzeugung von Schlüsseln benötigen, zu
wenig Entropie vorhanden ist. Auch wenn von den Interrupts nicht viel Entropie zu
erwarten ist, sollte die Verwendung der Interrupt-Ereignisse dieses Problem etwas
abmildern.
\cite{mueller@bsi2}
\end{comment}




\begin{figure}[H]
\centering
\input{add-interrupt-rnd.tex}
\caption{Processing of input parameters by function 'add\_interrupt\_randomness' before applying fast\_mix / mix\_pool\_bytes operations (valid for x64 / 64-bit Kernel only)} \label{fig:add-int-rnd}
\end{figure}

\begin{figure}[H]
	\centering
	\input{get-rnd-int-long.tex}
	\caption{Processing of input parameters by function 'get\_random\_int/long' (valid for x64 / 64-bit Kernel only)} \label{fig:get-rnd-int-long}
\end{figure}



%\begin{mdframed}
%\begin{tabularx}{\columnwidth}{XXl}
%\begin{tabularx}{\textwidth}{ll}
%%	\caption{Description of input parameters proccessed by func. 'add\_interrupt\_randomness'}
%%	\label{tab:add-int-rnd-desc}\\
%	\textbf{jiffies}&Igel\\
%	\textbf{cycles counter}&Dienstag\\
%	\textbf{irq}&\\
%	\textbf{ip}&\textit{Instruction Pointer}
%	\caption{Description of input parameters proccessed by func. 'add\_interrupt\_randomness'}
%\end{tabularx}
%\centering
%\begin{table}[H]
%	\begin{tabular}{ll}
%	\textbf{Jiffies}&Nr. of ticks occured since system startup.\\
%	\textbf{Cycles Counter}&Nr. of CPU-cycles since system startup.\\
%	\textbf{irq}&Interrupt Request \\
%	\textbf{ip}&\textit{Instruction Pointer}
%	\end{tabular}
%	\caption{Description of input parameters proccessed by func. 'add\_interrupt\_randomness'}	
%\end{table}

% jiffies . Incremented for each timer interrupt.
% . also known as \textit{Time Stamp Counter}.

%	\cite{kernlrandmc}
		
%\end{mdframed}


%\begin{tabularx}{\columnwidth}{XXl}
%	jiffies&Schnecke&Igel\\
%	cycles counter&Hier ist ein langes Wort Hier ist ein langes Wort Hier ist ein langes Wort Hier ist ein langes Wort &Dienstag\\
%	irq&&\\
%	ip&&
%\end{tabularx}
%
%
%
%\begin{mdframed}
%\begin{description}
%	\item [jiffies] sadfasdfsadf
%	\item [cycles counter] asdfasdfasdf
%	\item [irq] asdfasdfasdf	
%	\item [ip] 
%\end{description}
%\cite{kernlrandmc}	
%\end{mdframed}




\section{Conclusion}
The final section of the chapter gives an overview of the important results
of this chapter. This implies that the introductory chapter and the
concluding chapter don't need a conclusion.

%\lipsum[66]

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 
